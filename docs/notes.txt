With the spreadsheet model does a per-user pricing make sense or still an abstract sass unit in terms of server capacity or data volume and everything?


--------------

Is a fluid UI a good thing or bad? Does it mean that when you view it on a different device, everything is in a different place and it no longer seems right? 

--------------

I am getting that feeling of non-ending stream of ideas that come from hitting on a nerve. A gold mine. This feels right. This unlocks so many possibilities. 
Imagine being able to go into Arevel, drop in a csv file in a cell, then view the contents of that as a table in another cell, do all kinds of split, filtering and sorting and then be able to generate 2 or 3 files in other cells in different formats and you just click it to download it. Simple. And so freaking powerful. To do that right now would require so much manual process. Even these basic capabilities will make this exceed the limitations of excel. Excel has that core notion of a grid but so much functionality stuck outside of it in the UI layer, like sorting, or importing or exporting. This brings everything into the system so it's at your fingertips to do with as you need. 

-----------
So this can work. I think I am onto something here. 
This makes me think, what if instead of presenting this as the next generation programming language with the simplicity of spreadsheets, intead I present it as the next generation spreadsheet with the power of programming? 
Then it's not saying, oh this is a simpler watered down version of programming made to look like spreadsheets. Instead it's saying, this is a much more advanced more powerful spreadsheet, with the power of programming. 
Look, you can even make it build websites! 
And that gets a "wow" rather than if you phrase it as a language, then its like, ofcourse it can, and it does that worse than other languages. 
There are also a whole lot more people familiar with spreadsheets and comfortable with it than there are people who use programming, so when they see the message it will resonate and build off of existing experiences and have some baseline expectations rather than starting with the unknown of programming. 
Yes. This is interesting. It flips the approach of the product around completely. This is so much more compelling. 
This also greatly alleviates the concerns around it being web based or closed source or any of those kinds of things. 
That simply doesn't enter the picture. 
It also clarifies the questino of what do you do with this thing, what do you use it for, because a spreadsheet has a purpose and people are used to using it for all kinds of things, whereas a language is so vague and starts from scratch that you don't often turn to it as a solution unless absolutely necessary. It doesn't occupy the space in your mind as a common tool. 


---------------
So flexbox can't quite do what I want, but looks like css grids can. 
It's not well supported but it works. The world will catch up. 

----------

Sketched out some ideas on paper. I think I have a clear new direction for the UI. 
It even has a standard name. Masonry grid. That grounds me in the basis of Excel but gives 
me the space to have more rich content within it as well. 


----------

The design and UX of this app is just as important, if not more important than the technical pieces. 
This is a completely new paradgrim we're establishing. It has to make sense to people. They have to be able to learn what to do and how to do it. It has to be able to solve a lot of the common problems that come up with programming, namely debugging, performance, testing. 
For web pages, there is a mental model of frontend and backend. 
There are also classical systems of levels/layers in things like MVC. 
I think a hierarchical tree is a common enough metaphore for this kind of organization. People are used to having that on the sidebar, but usually in the form of a file tree. 
That can be our abstraction around modules and general code organization. 
It would give you controls for adding functions, etc. 
For the main code body, excel is the closest analogy. 
Does the plain, pre-existing grid make sense? 
Or would it make more sense to build it up incrementally line by line? 
Mental model wise, with spreadsheet people have a mental model of how it behaves when you change a value. 
What if it starts off like that, with a spreadsheet like interface except each cell is richer? 
It's not just filled with numbers, but it has spots for defining a name inline and can display the expression as well as the result. 
What if you could click into a cell and go deeper to define it? 
One benefit of an excel like interface is that you maintain the context as you work. It doesn't just disappear. 
With a grid we arrive again at one of the fundamental limitations of excel, which is that it's so unstructured. 
Everything is completely isolated. There is no groups. 
But what if that's an advantage? 
You do start with isolated, indendent things and when you need to, you select it and define it as a group. That would turn it into an array that you can work with as a whole. 
While each variable within it still has the full functionality level of a cell, so you can do things like call functions or give certain cells certain names. 
The grid does make it easy to do certain things without worrying about adding or removing cells. No need for layout or organization. 


-----------------

brew services start postgresql

-----------------

May 24th
So I've been thinking more about the question of the datastore. 
So it absolutely makes sense to have a postgres instance for much of the core application data. Things like all of the users, the cells themselves and anything else with any kind of structure. 
What is unclear is what to do with all of the user data. The data from their websites or from the files they upload. Data that isn't going to be structured, where maintaining schema migrations as they iterate won't be feasible. 
So the options I see for that are:
1: Continue using postgres. Pros: Simpler infrastructure management. Cons: Out of the box performance for json (Query time, memory, storage), weird-er update syntax. 
2: Use mysql instead for everything. Similar to 1, except different json semantics. A big difference is mysql is better suited for updates than postgres, but you'd only hit this at scale.
3: Use a separate mongo instance for user data. Pros: Better default tuning for json storage. Better case for sharding and scaling. Cons: Additional configuration and server management. Consistency, ecosystem, reliability. 
4: Use separate sqllite instances for each application. 
5: Use one of the elixir built in databases. Pros: Easy. Cons: Lack of tooling, backups, scaling. 

For now I will go with the operational simplicity and stick to json in postgres. 
With added indexes it should be efficient enough. 
I will invest the time to learn the syntax, as I need to anyway for the sql portion of it. 
It seems like the balanced choice here.


----------------------

May 23rd
Things I need next: 
Ability to add cells. 
Propagate changes to server for persistance. 
Connect to mongo.
Easy reset button. 

names. dependency tree.
Lists, functions.
Tables.

Whatever structures I have should be optimized for readability. 
Not just looking good, but it fundamentally has to make sense at a glance what it is. 

---------------------

So I got basic react cell evaluation working with react. 
Kind of back to where things were. 
TODO: remove live view. Not really urgent. 
I think I'm at a point where it makes sense to start adding persistance. 
Otherwise I will need to come up with a way to handle a lot of the modifications in code that would need to be changed later on anyway. 
So instead I think it makes sense to add it in now. 
Going with mongo. I think I did evaluate that vs postgres at at time. Postgres does have quite a lot of advantages and I will likely use it for our own user model, but the sharding capabilities of mongo make it fairly compelling. 

mongod

From https://scalegrid.io/blog/comparing-in-memory-databases-redis-vs-mongodb-percona-memory-engine/
the latency is reasonable for my use-case. 
And the incremental advantage of redis isn't worth the complexity at this low scale. 
So skip having a cache layer for now and introduce it later into the system. 


----------------

May 22nd
Goal: Get the cell expression flow working with react.
Remove all the live view code. 
Could I use it for some pieces like signup verification? 
Sure, but it's more overhead to maintain without necessarilly providing sufficient benefit.

-----------

Some of the ideas from immutable js, flux, elm architecture and react work well here. 
They give a baseline for a good solution to handling change and state in a declarative, immutable world.
I believe I can use it with this system as well. 
In a sense then it becomes a UI interface to defining react style code for a lot more things than UI development. 


------------------------------------

May 21st
I still need to figure out mutations and side-effects. 
I have to make the pragmatic choices beyond just building a pure, elegant system. 
The choice should map closely to our mental model of the world and how things operate in the world. 
That's muddied by the years of traditional programming. We come to think of that as normal, but it isn't.


------------------------------------

May 20th
I'm going back to the react approach and abandoning live view. 
The whole advantage of live view is greater productivity with backend only code. 
But it has far too much magic and hides away complexity and it's not mature enough to make it all configurable yet. 
It's taking a risk that is un-necessary and isn't core to the product. 
I should use the tried and true technology in this case. 


------------------------------------

May 19th
That Simon Sinek talk on Youtube resonated with me. We need to align our messaging around Why. 
The way we write software today is cumbersome and error prone. 
There has to be a better way to program. We are not going to be programming like this, writing sequential instructions for CPUs to execute in text files with syntax and conventions that take years to learn and master. 
There has to be a better way to build software. 
Arevel is a next generation programming language in early beta. 
It's a ground up rethinking of what programming can be in this day and age, without being encumbered by the design constraints of a different era that has limited traditional programming languages. 
That's the why and the what. 
I think it'll be good to publish an open plan of how we will do it. 

We'll build a language that is easier to learn and adopt. By being a browser based system, it allows anyone to start coding in Arevel in minutes without needing to download, install and configure another language and toolchain. 
Arevel is designed from the ground up as a general purpose language, but focused on the problem of developing rich websites. 
We will build off of existing ecosystem. We will prioritize making it easy for anyone to publish libraries and collaborate. 
This ecosystem and integrated environment will make it vastly more productive to develop software in Arevel than otherwise. 
The health of the ecosystem depends on the community. The community will grow virally as users share what they built on Arevel and build forks off it. Building off of the backs of others work will ensure you can focus on the bits that are critical to. 
This is already how we develop software today in this internet age. Collaboratively, building on each other's expertise. Except now it's supported wholly by the language. 
This in turn creates a rich ecosystem, an active community and a first-class language all of which enrich each other. 
This all leads to a rich network effect strengthening the language. 
Arevel frees you from the mundane details to allow you to solve ever more complex problems than before. 

-----------

Phoenix live view vs react.
React is more established, with better primitives and patterns. 
Live view is experimental. The promise is the ability to just write backend code. 
Do I care if the code is on the backend or the frontend? 
Behavior difference is that it can support live data more easily. 
What should I optimize for?
Is there some benefit that live view would give me that I wouldn't/couldn't get otherwise?
It maps to the domain model well because the server side is stateful. 
Rather than the api request/response cycle which react would give me out of the box.
I would then need to hack react to work with a websocket and a stateful system. 
This configuration allows me to keep an editable running version of the code running on the backend 
(which we previously decided execution should be on the backend so we can enable servers).
It also allows classes of changes like a timer running which would update things. 
Or long-running code that multiple people can observe while it's processing one massive file. 


-------------------

May 18, 2019
Don't over optimize for what you have to deal with at scale. 
Instead get the basics of the language down with what minimal things you need so you can ship and build some useful things off of this.

I have a basic live server. 
I think next up I need to convert the arevel code to the live server piece. 
All of this is with the assumptiption that this will speed up my development pace because it's all backend. 
No need to replicate any logic on the frontend. 

-----------------

Starting implementing the cell in react, but switching to trying to do it in live view. 
This is an experimental paradgrim but I think it has value for this kind of use-case where most actions
are modifying data which would require a server call anyway. 

I'm pretty sure I can handle our Arevel users with live view and have a websocket for each concurrent user. No problem. 
Where we run into limits is if we plan on providing this as a feature for the premium tier customers. 
Their sites may have a lot more visitors and if we need to maintain connections in parallel for all of them... 
Well its the same problem as discord right? They have all of these rooms where people idle and you need to send broadcast events. 
They solved it with elixir. So it seems solvable. 
And anyway I don't think I need to handle it all on one server. 
I need to design this all in a way such that it can span servers.
--------------

May 17th
What do I call the primary structure in this?
Cell? Expression? Block?

Block is a section. 
Cell is a unit. 
So cell seems to be the better word.
Try to remain similar to standard programming when possible.
Don't make everything your own weird esoteric thing.

Cell is the equivalent of an atom in something like lisp.

----------

Alright. I got expression evaluation working for math and some basic boolean. 
I'm not sure how to handle strings. Should I have a string concatanation operator?

------------------------

May 13th
Same mini goal. Need to actually work on it rather than getting caught up with distractions. 
For the frontend framework, I'm going to use React this time rather than vue based on my experience last time. 
Yes, vue is great and I love it but react just has a significantly larger ecosystem and that is hard to ignore. 
They're close enough on performance (file size, runtime) that it doesn't make sense to use the #2 based on personal taste. 
I am also not going to bother with typescript this time. Just going to stick to pure javascript. 
I just haven't found any significant benefit to it and it's yet another semi-niche tool to add to the toolchain that isn't necessary. 
Only add things that are absolutely necessary to make things work. Choose the popular defaults - hard to go wrong with that. 
If we need to we can adopt it later incrementally. 
----------

May 11th
Current mini goal - Frontend UI for entering an expression. Backend for evaluating it. 

---------
May 10th
Took a break for some work stress the past week. I've arrive at a decision in the background. It's a clean separation to have the frontend deal with all of the parsing and transforming into a lisp format. 
The backend then is purely responsible for taking the lisp style code, storing it and executing it. 
If needed we can provide an API endpont to do the parsing for you, but it's really not needed. 


----------------------------

This is a difficult decision to make with a lot of impact on the future architecture and workings of this system. I don't have all of the information to make the perfect decision. I can only do what is best immediately based on the more concrete requirements I have at the present. 
I am going to go with having the parsing happen on the frontend. That will let me treat the frontend layer like it's a pure representation of code and have it be responsible for modifying that code. 
The backend simply stores and executes the code. 
That's a clean division. The division does mean having to have similar bits of code on the frontend and the backend. 
Having the two systems line up perfectly. But you save computation on the backend. 
And anyway the frontend does need to have some idea of the representation of code anyway in order for it to do its job of representing the code in the editor UI. 
So really, there has to be a representation on both ends, the question is really on the transformation. 
From code to representation and from representation modifications to code. 
I don't fully know whether this live view thing is going to work out or not. That is so very very experimental and a bit premature as a technology. I shouldn't over-design around it.

------------------------

This is a good question to consider. I don't know why I didn't think of it up front. 
What all should be done on the frontend vs the backend?
Really, all the backend needs at the end of the day is the representation of the code it can execute. That's where my previous system didn't work well because all of the execution logic was in the browser as well, making it unsuitable for servers and backend APIs. 
Now, does the backend need to know/care about parsing or not?
Well, are there any disadvantages if we do parse it in the backend - other than complexity and effort? 
Yes. The UI layer needs to know that information as well for it to work. 
Well, why not just share that information with the UI layer then but still keep the backend the source of truth?

Let me frame it another way. 
Will the frontend need to be able to parse expressions without relying on the server?
Will the server need to be able to parse expressions without relying on the client?

At this point in time it's actually kind of unclear. 
One point worth making is if there are raw types that behave differently between the parsing environment and the execution environment. 
For example, native javascript doesn't support big numbers. Elixir does. But elixir and javascript both don't support 0.1 + 0.2 == 0.3


----------------
Why am I doing all of this parsing on the backend anyway? Why can't that be done on the frontend and passed back so the backend can just do evaluation? 
The frontend transforms the code into a form that can be evaluated. Ideally, some kind of lisp structure.
It has to do some of that anyway for the UI right? And if we want to do mapping from variable name users type in to an identifier - that's likely done at the UI layer. 
The UI/frontend knows and manages the AST and the backend manages execution and state. 
Does that mean I'm throwing away all of this work? Yep. Sometimes that's what you have to do to arrive at a good solution. 
It wasn't all for naught - I've learned a few things along the way and gotten more familiar with Elixir. 
I love the unit testing system in Elixir. It's quite nice. 
-----------

I'm learning a whole lot more about parsers than I ever cared to learn about this subject. Trying to implement this as a recursive descent parser with precedence climbing has been enjoyable when it's working and hell when it breaks. 
It's pretty much unmaintainable in this form. I love the combinator part of it. I love that this is just elixir code. 
I hate the deeply nested structure emmited by the parser and I hate how error prone and non-extensible the precedence system is. 

Going to try to write this piece as a pratt parser. 
Once I have all of this working, I am going to put this up as a library similar to jsep. 
That way I am contributing back some open source work regardless of the success or failure of Arevel. 

------------------------------
April 27th
Use `is` and `is not` rather than == and !=. The = sign has lost it's meaning with programmers. 
Yes, this requires typing more but it will be easier to read and understand for new programmers. 

To have inline function calls, write an expression and define temporary scoped variables under it which are accessible only in that expression evaluation, 
So any function call is in that list. 

Being able to call functions inline in an expression is useful. Atleast give the option of that for the experts. 


-----------
Alright. Enough theory. Time to write some code. 
In the next 25 minutes, the goal is to extend the web server to just evaluates a hard-coded function of 1+1 and returns the result. Simple. 
-------

So for parser, there's the erlang built in parser and then NimbleParsec. The erlang leex and yacc seem more powerful but Nimble is seems simpler and faster for the limited use-case I have. 

--------
Did some thinking during Easter service. I think there's two versions of this. Arevel Script - which gives you the ability to write programs that take inputs and gives you an output. It doesn't care at all that it's happening as part of a web request - it just gives you some high level abstractions that enable you to get input (text, files, whatever) and spit out an output. 
The results are saved so they can be returned when you visit that page again. Each execution generates a URL which can be saved and shared. 
It all happens within an Arevel provided UI. 
You get some minimal control over the output, but it's also very high level. 

The secondary mode of operation is Arevel App. There the HTTP requests as well as websocket requests all just feed into the system as parameters and then you process it and return things. 

I don't know if I've solved the push pull conflict entirely. 

Using the Lua VM really doesn't give me that much more. I think it may be better to start with a lower level parser. 

--------------
I can also think of it as if there's really no parser layer in this format. The UI is a substitute for parser. 
The only time parsers come into play is for inline expressions. 
For those, you can use the trick liveview uses

static: [
    "(1 + "
    ") / 2"
], 
dynamic: [
    var1,
]
which get zipped together to form "(1 + var1) / 2"

---------------

I do question whether this is the best approach or if it will be better to just do it the hard way. 
This is my core value prop. This is central to my business. I should not shy away from the difficulty of implementation and just go through the initial pain of setting it up. The flexibilty it buys me later on is worth it. 
Reference how it's done, but do it yourself. 
Yes, I should implement it, but I don't have to do it right now. 
First get things wired up so you can actually run code. 
Then rip out the luerl bits for the other VM when necessary rather than up front. 


---------------


April 20th, 2019
There is eval functionality that could be leveraged for maximum speed of execution. 
It won't have the same characteristics of execution as the underlying code though. 
And there's no sandboxing to prevent it from having side-effects on the system. 

I'm glad I looked into this. 
There's https://github.com/rvirding/luerl by Virding which might provide some of the 
sandboxed execution I need. 

Ok. That might work. I have some basic representation which gets "compiled" down to lua code and then executed on the erlang vm. 

So the data format is what the user sends us - the untrusted data. 
The compilation has to happen on the backend so it can generate trusted code. 

This is great! There is support for sandboxing. And it has hooks I can use to build in extra functionality, disable things selectively, set process prioritity, count execution reductions, etc. Awesome!

The documentation for this library is nonexistant (or rather dense) and it's all kind of black magic, but I think it does what I need it to. Oh, and it's all in Erlang not in elixir. 
