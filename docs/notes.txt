May 18, 2019
Don't over optimize for what you have to deal with at scale. 
Instead get the basics of the language down with what minimal things you need so you can ship and build some useful things off of this.

I have a basic live server. 
I think next up I need to convert the arevel code to the live server piece. 
All of this is with the assumptiption that this will speed up my development pace because it's all backend. 
No need to replicate any logic on the frontend. 

-----------------

Starting implementing the cell in react, but switching to trying to do it in live view. 
This is an experimental paradgrim but I think it has value for this kind of use-case where most actions
are modifying data which would require a server call anyway. 

I'm pretty sure I can handle our Arevel users with live view and have a websocket for each concurrent user. No problem. 
Where we run into limits is if we plan on providing this as a feature for the premium tier customers. 
Their sites may have a lot more visitors and if we need to maintain connections in parallel for all of them... 
Well its the same problem as discord right? They have all of these rooms where people idle and you need to send broadcast events. 
They solved it with elixir. So it seems solvable. 
And anyway I don't think I need to handle it all on one server. 
I need to design this all in a way such that it can span servers.
--------------

May 17th
What do I call the primary structure in this?
Cell? Expression? Block?

Block is a section. 
Cell is a unit. 
So cell seems to be the better word.
Try to remain similar to standard programming when possible.
Don't make everything your own weird esoteric thing.

Cell is the equivalent of an atom in something like lisp.

----------

Alright. I got expression evaluation working for math and some basic boolean. 
I'm not sure how to handle strings. Should I have a string concatanation operator?

------------------------

May 13th
Same mini goal. Need to actually work on it rather than getting caught up with distractions. 
For the frontend framework, I'm going to use React this time rather than vue based on my experience last time. 
Yes, vue is great and I love it but react just has a significantly larger ecosystem and that is hard to ignore. 
They're close enough on performance (file size, runtime) that it doesn't make sense to use the #2 based on personal taste. 
I am also not going to bother with typescript this time. Just going to stick to pure javascript. 
I just haven't found any significant benefit to it and it's yet another semi-niche tool to add to the toolchain that isn't necessary. 
Only add things that are absolutely necessary to make things work. Choose the popular defaults - hard to go wrong with that. 
If we need to we can adopt it later incrementally. 
----------

May 11th
Current mini goal - Frontend UI for entering an expression. Backend for evaluating it. 

---------
May 10th
Took a break for some work stress the past week. I've arrive at a decision in the background. It's a clean separation to have the frontend deal with all of the parsing and transforming into a lisp format. 
The backend then is purely responsible for taking the lisp style code, storing it and executing it. 
If needed we can provide an API endpont to do the parsing for you, but it's really not needed. 


----------------------------

This is a difficult decision to make with a lot of impact on the future architecture and workings of this system. I don't have all of the information to make the perfect decision. I can only do what is best immediately based on the more concrete requirements I have at the present. 
I am going to go with having the parsing happen on the frontend. That will let me treat the frontend layer like it's a pure representation of code and have it be responsible for modifying that code. 
The backend simply stores and executes the code. 
That's a clean division. The division does mean having to have similar bits of code on the frontend and the backend. 
Having the two systems line up perfectly. But you save computation on the backend. 
And anyway the frontend does need to have some idea of the representation of code anyway in order for it to do its job of representing the code in the editor UI. 
So really, there has to be a representation on both ends, the question is really on the transformation. 
From code to representation and from representation modifications to code. 
I don't fully know whether this live view thing is going to work out or not. That is so very very experimental and a bit premature as a technology. I shouldn't over-design around it.

------------------------

This is a good question to consider. I don't know why I didn't think of it up front. 
What all should be done on the frontend vs the backend?
Really, all the backend needs at the end of the day is the representation of the code it can execute. That's where my previous system didn't work well because all of the execution logic was in the browser as well, making it unsuitable for servers and backend APIs. 
Now, does the backend need to know/care about parsing or not?
Well, are there any disadvantages if we do parse it in the backend - other than complexity and effort? 
Yes. The UI layer needs to know that information as well for it to work. 
Well, why not just share that information with the UI layer then but still keep the backend the source of truth?

Let me frame it another way. 
Will the frontend need to be able to parse expressions without relying on the server?
Will the server need to be able to parse expressions without relying on the client?

At this point in time it's actually kind of unclear. 
One point worth making is if there are raw types that behave differently between the parsing environment and the execution environment. 
For example, native javascript doesn't support big numbers. Elixir does. But elixir and javascript both don't support 0.1 + 0.2 == 0.3


----------------
Why am I doing all of this parsing on the backend anyway? Why can't that be done on the frontend and passed back so the backend can just do evaluation? 
The frontend transforms the code into a form that can be evaluated. Ideally, some kind of lisp structure.
It has to do some of that anyway for the UI right? And if we want to do mapping from variable name users type in to an identifier - that's likely done at the UI layer. 
The UI/frontend knows and manages the AST and the backend manages execution and state. 
Does that mean I'm throwing away all of this work? Yep. Sometimes that's what you have to do to arrive at a good solution. 
It wasn't all for naught - I've learned a few things along the way and gotten more familiar with Elixir. 
I love the unit testing system in Elixir. It's quite nice. 
-----------

I'm learning a whole lot more about parsers than I ever cared to learn about this subject. Trying to implement this as a recursive descent parser with precedence climbing has been enjoyable when it's working and hell when it breaks. 
It's pretty much unmaintainable in this form. I love the combinator part of it. I love that this is just elixir code. 
I hate the deeply nested structure emmited by the parser and I hate how error prone and non-extensible the precedence system is. 

Going to try to write this piece as a pratt parser. 
Once I have all of this working, I am going to put this up as a library similar to jsep. 
That way I am contributing back some open source work regardless of the success or failure of Arevel. 

------------------------------
April 27th
Use `is` and `is not` rather than == and !=. The = sign has lost it's meaning with programmers. 
Yes, this requires typing more but it will be easier to read and understand for new programmers. 

To have inline function calls, write an expression and define temporary scoped variables under it which are accessible only in that expression evaluation, 
So any function call is in that list. 

Being able to call functions inline in an expression is useful. Atleast give the option of that for the experts. 


-----------
Alright. Enough theory. Time to write some code. 
In the next 25 minutes, the goal is to extend the web server to just evaluates a hard-coded function of 1+1 and returns the result. Simple. 
-------

So for parser, there's the erlang built in parser and then NimbleParsec. The erlang leex and yacc seem more powerful but Nimble is seems simpler and faster for the limited use-case I have. 

--------
Did some thinking during Easter service. I think there's two versions of this. Arevel Script - which gives you the ability to write programs that take inputs and gives you an output. It doesn't care at all that it's happening as part of a web request - it just gives you some high level abstractions that enable you to get input (text, files, whatever) and spit out an output. 
The results are saved so they can be returned when you visit that page again. Each execution generates a URL which can be saved and shared. 
It all happens within an Arevel provided UI. 
You get some minimal control over the output, but it's also very high level. 

The secondary mode of operation is Arevel App. There the HTTP requests as well as websocket requests all just feed into the system as parameters and then you process it and return things. 

I don't know if I've solved the push pull conflict entirely. 

Using the Lua VM really doesn't give me that much more. I think it may be better to start with a lower level parser. 

--------------
I can also think of it as if there's really no parser layer in this format. The UI is a substitute for parser. 
The only time parsers come into play is for inline expressions. 
For those, you can use the trick liveview uses

static: [
    "(1 + "
    ") / 2"
], 
dynamic: [
    var1,
]
which get zipped together to form "(1 + var1) / 2"

---------------

I do question whether this is the best approach or if it will be better to just do it the hard way. 
This is my core value prop. This is central to my business. I should not shy away from the difficulty of implementation and just go through the initial pain of setting it up. The flexibilty it buys me later on is worth it. 
Reference how it's done, but do it yourself. 
Yes, I should implement it, but I don't have to do it right now. 
First get things wired up so you can actually run code. 
Then rip out the luerl bits for the other VM when necessary rather than up front. 


---------------


April 20th, 2019
There is eval functionality that could be leveraged for maximum speed of execution. 
It won't have the same characteristics of execution as the underlying code though. 
And there's no sandboxing to prevent it from having side-effects on the system. 

I'm glad I looked into this. 
There's https://github.com/rvirding/luerl by Virding which might provide some of the 
sandboxed execution I need. 

Ok. That might work. I have some basic representation which gets "compiled" down to lua code and then executed on the erlang vm. 

So the data format is what the user sends us - the untrusted data. 
The compilation has to happen on the backend so it can generate trusted code. 

This is great! There is support for sandboxing. And it has hooks I can use to build in extra functionality, disable things selectively, set process prioritity, count execution reductions, etc. Awesome!

The documentation for this library is nonexistant (or rather dense) and it's all kind of black magic, but I think it does what I need it to. Oh, and it's all in Erlang not in elixir. 
